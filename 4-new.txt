### 3. Изследване на данни с една променлива - продължение ###

x <- rnorm(1000) #rnorm генерира N нормално разпределени данни. 
Пример за нормално разпределени данни:  Височина човек, кръвно налягане. Нормално разпределените данните имат камбановидна хистограма или много добре изглеждащ (центриран) boxplot.
boxplot(x)
hist(x)

#За R има много пакети, които съдържат както нови функции, а също така и примерни данни, с които да работим.
install.packages("UsingR") #Тази функция инсталира пакети съдържащи библиотеки.
library(UsingR) #След като имаме наличен даден пакет трябва да го заредим. Това става с функцията 'library'

Пакета, който инсталирахме съдържа функция за визуализиране едновременно на кутия с мустаци, хистограма и rug-чета. В тези пакети има всякакви подобни полезни неща.
simple.hist.and.boxplot(rnorm(1000)) 

x = c(.314,.289,.282,.279,.275,.267,.266,.265,.256,.250,.249,.211,.161)
H = hist(x, xlab = "Some results")
*xlab идва от етикет (label) на оста Ox. ylab е за етикет по ординатата

str(H)
*Дава информация за структурата на H. 
> str(H)
List of 6
 $ breaks  : num [1:5] 0.15 0.2 0.25 0.3 0.35 -> разделенията на интервалите
 $ counts  : int [1:4] 1 3 8 1 				  -> брой наблюдения в интервал
 $ density : num [1:4] 1.54 4.62 12.31 1.54   -> плътност на разпределението. Това преобразувано в проценти ни дава колко процента от наблюденията са в интервал.
 $ mids    : num [1:4] 0.175 0.225 0.275 0.325 -> средните стойности на интервалите.
 $ xname   : chr "x"
 $ equidist: logi TRUE
 - attr(*, "class")= chr "histogram" 		  -> H е тип хистограма.

Достъпване на данни:
H$breaks -> извежда стойностите на крайните интервали

attach(H) -> "влизаме" в H. 
#извеждаме само каквото искаме. аналогично на H$counts
counts
mids
lines(c(min(breaks), mids, max(breaks)), c(0, counts, 0), col = "blue") -> прави навързани отсечки от най-малкото после минава през средите и накрая през най-голямото. Височината е първо 0, после спрямо броя наблюдения в интервал, после пак 0 и накрая задаваме цвят.
detach(H) "излизаме" от H.

Цялото това нещо съкратено: (удобствата на библиотеката, която заредихме)
simple.freqpoly(x)

Зареждане на данни от инсталиран и зареден пакет:
Чрез функция data извикана без аргумент може да проверим наличните бази от данни

data(faithful) -> зарежда данни за работа.
faithful
head(faithful) -> показва първите няколко реда
head(faithful, 15) -> показва първите 15 реда
Данните показват измервания през колко време в секунди гейзера Faithful е изригвал и съответната продължителност на изригването.
https://en.wikipedia.org/wiki/Old_Faithful

nrow(faithful) -> връща брой редове на данните
ncol(faithful) -> връща брой колони на данните

faithful$eruptions -> достъпваме само стойностите под eruptions

attach(faithful) 
hist(eruptions, breaks=15) 
B <- hist(eruptions, breaks=15)
lines( c(min(B$breaks), B$mids, max(B$breaks)), c(0,B$counts,0), col="green" )
simple.freqpoly(eruptions, breaks=15)
detach(faithful) 


### 4. Изследване на данни с 2 променливи ###
Често връзките (зависимостите) между 2 величини представляват интерес за изследване.
Например, дали височината и широчината на човек са свързани..
Дали годините и кръвното налягане са зависими едно от друго
Дали ново лекарство е по-добро от текущо съществуващото
Дали спортист е по-добър от друг спортист
и тн..

За изследване на данни с 2 променливи в R се ползват същите функции, като при изследването на данни с 1 променлива, но по различен начин.

smokes <- c("Y","N","N","Y","N","Y","Y","Y","N","Y") -> N броя хора пушачи/непушачи
amount <- c(1,2,2,3,3,1,2,1,3,2) -> по колко часа учи на ден
table(smokes, amount)
tmp <- table(smokes, amount) -> таблица, показваща статистика за брой часове прекарани в учене на пушачи/непушачи
prop <- function(x) x/sum(x) -> дефиниране на функция преобразуваща данните в пропорция 
apply(tmp, 1, prop) -> apply прилага функция (prop) върху таблицата (tmp). Таблицата е представена като двумерен масив. Вторият аргуемнт (1) означава че функцията ще бъде приложена на ниво редове
apply(tmp, 2, prop) -> същото, но е приложено за колоните.

Определяне на точност на числата с плаваща запетая:
options(digits=3)
options(digits=5)

Реализираната в R функция, правеща пропорциално отношение върху данни в таблица е следната:
prop.table(tmp,1)  -> пропорция на таблицата на ниво редове
prop.table(tmp,2)  -> на ниво колони 
prop.table(tmp)  -> пропорция върху цялата таблица


barplot(table(smokes, amount), col=rainbow(2)) #показва графика (не много ясна) по колко часа учат съответно пушачи/непушачите
barplot(table(amount, smokes), col=rainbow(3)) #показва почти същото като горното. Цветовете се редуват.
barplot(table(smokes, amount), col=rainbow(2), main="table(smokes, amount)", beside=TRUE) #тези са може би една идея по-разбираеми
barplot(table(amount, smokes), col=rainbow(3), main="table(amount, smokes)", beside=TRUE) #същите като горните 2, но са разделени на отдални, съседни картинки.

Нека направим изследване, дали лекарство има ефект върху група от хора. 
Едната група не е третирана с лекарство(control), другата е (experimental). 
Стойностите показват резултати на група от хора след третирането им с лекарство в продължителност на 1 седмица.
x <- c(5, 5, 5, 13, 7, 11, 11, 9, 8, 9)
y <- c(11, 8, 4, 5, 9, 5, 10, 5, 4, 10)
За да изследваме и сравним резултатите може да направим общ boxplot
boxplot(x, y) #вижда се, че показателите са се повишили.

Линейна регресия:
Деф: 
Статистически метод за построяване на (евентуално) приемлива линейна връзка между група независими променливи x1,x2...,xn, и зависима променлива y. Къ
дето y наричаме индикатор или контролна величина.
т.е. построяваме линеен математически модел, с чиято помощ могат да се правят прогнози за състоянието на y при различни данни за x.

Пример за дъската:
Килограми + години, как се разминават, ама се въртят около нещо. (да е наопаки графиката, за да не се вижда с око от пръв поглед.)
Формула за пресмятане:
(да взема от разписаните на листче)

Нека имаме стойностите:
(1,3), (3,1), (4,1), (5,2)
Да построим линеен модел описващ максимално добре данните. Целта е да знаем около какво се въртят данните.
Уравнение на права:
y = a + bx
mean(y) = a + b*mean(x)

a = mean(y) - b*mean(x)
b = ( mean(x)*mean(y) - mean(x*y) ) / ( ( mean(x)^2 ) - mean(x^2) )



#Къде да бъдат инсталиране пакетите:
#Windows
.libPaths('C:/ala-bala-with-write-permissions')
#Linux
.libPaths('/home/username/directory/')

#Инсталиране на пакет, съдържащ реализирани функции и данни от изследвания:
install.packages("UsingR")
#Зареждане на библиотеката:
library(UsingR)
#зареждане на данните, с които ще работим
data(home)

#Как да се запознаем с данните, с които работим?
data() #дава информация за всички налични данни от всички инсталирани пакети
data(package="UsingR") #дава информация за данните само от пакета UsingR
#четем описанието и се опитваме да го разберем.
 
#информация за структурата на данните
str(home)
'data.frame':   15 obs. of  2 variables:
 $ old: num  64200 72100 87600 59000 83200 ...
 $ new: num  257500 276800 364600 160400 333500 ...

#data.frame е тип данна, която е подобна на матрица с разликата, че може да имаме различни типове данни в колоните.
#първата колона има име "old"
#втората колона "new"

attach(home)
x <- old
y <- new

plot(x,y)

Построяване на линеен модел върху данните
abline(lm(y~x))
#~ е оператор, с който указваме коя е зависимата променлива.

cor(x,y) #ни дава корелационните коефициент на двете величи.
#корелация е в [-1,1], като ако е отрицателна се нарича отрицателна корелация, а ако резултатът е положителен се нарича положителна корелация.
#имаме значима връзка, когато сме близко до -1 или до 1 и слаба, когато сме около 0.
#негативна корелация се получава, когато зависимата променлива намаля с времето. 
Пример за негативна корелация:
Заплатата, която получавам през годините:
1ва година 1000 лева
2ра година 500 лева
3та година 250 лева
4та година издъхвам на спестявания от първата

Зависимостта между заплатата ми и годините ми стаж има строга връзка, но е намаляща :(

detach(home)

#данни "florida"
data("florida")
#данните са за броя гласувалите, за президент в различни щати.
Построяване на линеен модел за броя гласували в различните щати за кандидат-президентите Bush и Buchanan
attach(florida)
simple.lm(BUSH, BUCHANAN) #аналогично на plot(BUSH, BUCHANAN) & abline(lm(BUCHANAN~BUSH))
cor(BUSH,BUCHANAN)

#наблюдават се два outlier-a (драстично различаващи се резултати)
#идентифициране на два outlier-а става така:
identify(BUSH, BUCHANAN, n=2)
#селектираме с мишката 2та outliera и като резултат получаваме индексите им в масива.
BUSH <- BUSH[-50] #(всички стойности без 50тата)
BUCHANAN <- BUCHANAN[-50]
simple.lm(BUSH, BUCHANAN)
cor(BUSH,BUCHANAN) #значително по-голяма зависимост между данните.
