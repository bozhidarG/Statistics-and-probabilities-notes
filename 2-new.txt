### ­ 2. Data ­ ###

Преговор от упр 1:
Присвояване на стойност на променлива:
x <- 5 #числа с плаваща запетая. В R се наричат numeric
x <- 7L #целочислени числа.
x <- "Highway to hell" #низ

#Основен начин за записване на данни в R е чрез използването на вектори.
#Векторите могат да съдържат елементи само от един и същи тип (числа, стрингове и 
т.н.).

#Създават се с функцията 'c'.
x <- c(2,3,0,3,1,0,0,1)

#Елементи от вектора могат да се достъпват с изписването на индексите им (един индекс 
или вектор от индекси) в квадратни скоби.

#Индексирането започва от 1.
x[2] #Връща втория елемент
x[c(4,1)] #Връща четвърти и първи елемент
x[5:8] #Връща от пети до осми елемент
x[-4] #Връща всички елементи БЕЗ четвъртия
x <- c(x,18,19) #добавяме 2 елемента към края на вектора x

#Всъщност операторът ':' е частен случай на функцията 'seq' и създава вектор от 
последователни цели числа.
18:22 #Прави същото като 'c(18, 19, 20, 21, 22)' или 'seq(18,22,1)'.
seq(from = 3, to = 4, by = .1) #Вектор с начало 3, край 4 и стъпка .1

#Можем да извършваме логически операции по ,,стандартния'' начин:
1==2 #проверява дали 1 е равно на 2 
1!=2; 1<2; 1>2; 1<=2; 1>=2 #проверява аналогично на горното, но спрямо различен оператор

#Същите тези операции се извършват покомпоненто, когато са приложени върху вектор
x==1 #връща вектор от стойности за всяка компонента в зависимост от това дали 
условието е изпълнено или не

#Можем да използваме вектор от булеви стойности, за да достъпим определени 
елементи от вектор

x[c(TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE)] #Това връща тези 
елементи, на които съответства стойност 'TRUE', т.е. 1ви, 4ти, 5ти и 8ми

#Извличане само елементите, които отговарят на определено условие
x[x<3 & x>=1] #Връща елементите, които са по­малки от 3 И ('&' е конюнкция, а '|' е 
дизюнкция) по-големи или равни на 1

#Някои основни функции, които работят с вектори:
which(x==1) #Връща индексите на елементите, за които е изпълнено условието (т.е. 
връща индексите на елементите, които имат стойност 'TRUE' във вектора от булеви 
стойности 'x==1')
length(x) #Дава дължината на вектора, т.е. броят на елементите му
min(x); max(x) #Връщат съответно минималната и максималната стойност измежду 
елементите на вектора
mean(x) #Дава средното аритметично (извадковото средно, ако вложим  
статистически смисъл) на елементите на вектора
sum(x) #Дава сумата на елементите на вектора
sum(x)/length(x) == mean(x) #връща TRUE
sort(x) #Сортира елементите на вектора във възходящ ред. Статистическа 
интерпретация: прави ни вариационен ред от наблюденията във вектора
median(x) #Дава медианата (средното наблюдение във вариационния ред)
var(x) #Дава извадковата дисперсия
sum((x-mean(x))^2)/(length(x)-1) == var(x) #Това е формулата, с която се 
изчислява извадковата дисперсия
sd(x) #Стандaртното отклонение на извадката (корен от извадковата дисперсия)
sd(x) == sqrt(var(x))
cummin(x); cummax(x) #Дават вектор от текущите минимуми и максимуми до момента 
(имената идват от cumulative и min/max.)
diff(x) #Дава вектор, на който всяка компонента е разликата между текуща и предхождаща 
компонента на аргумента. 'length(diff(x))==length(x)-1' е вярно, т.к. за първия 
елемент на 'x' няма с какво да се образува разлика

Решения на задачите от Section 2:
1.
miles <- c(65311, 65624, 65908, 66219, 66499, 66821, 67145, 67447)
x <- diff(miles)

Резултатът ни дава информация колко километра сме изминали преди да заредим гориво.

max(x)
min(x)

2.
x <- c(17, 16, 20, 24, 22, 15, 21, 15, 17, 22)
max(x)
mean(x)
x[which(x==24)]=18
mean(x)
sum(x>=20) #получаваме колко пъти сме пътували повече от 19 минути.
sum(x<17)/length(x) #получаваме процентно колко пътуваме по-малко от 17 минутки

3.
bill <- scan()
46 33 39 37 46 30 48 32 49 35 30 48

sum(bill)
min(bill)
max(bill)
sum(bill>40)
sum(bill>40)/length(bill)

4.
x <- scan()
9000 9500 9400 9400 10000 9500 10300 10200

mean(x) #към момента преценяме на око дали средните са горе-долу еднакви спрямо сайта на Edmund. След няколко упражнения ще изучим статистически метод, чрез който можем по-адекватно от метода "на око" да преценим дали средните са приемливо еднакви.

min(x)
max(x)
Джани би платила max(x), защото вярва, че кола на подобна цена ще е в полу- перфетно състояние.
Данчо би платил min(x)-1500, защото вярва, че част от парите могат да бъдат оползвотворени по-добре в клуб 33.

5.

6.
x <- c(1, 8, 2, 6, 3, 8, 5, 5, 5, 5)
sum(x)/length(x)
log10(x)
(x-4.4)/2.875
diff(range(x))
