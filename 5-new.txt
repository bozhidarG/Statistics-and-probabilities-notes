#Section 5#
---Изследване на данни с много променливи---

Мнооого често в статистиката данните са представени в табличен вид, където колоните са различни променливи, а всеки ред представлява дадено измерване на променливите.

Пример за табличен вид данни са данните home, от пакета "UsingR".
Те се състоят от две колони, едната съдържa информация за цените на имотите в Ню Джърси през 1970 година, а втората съдържа информация за цените им през 2000 година.
На всеки ред от таблицата са съответно отчетените стара и нова цена на имот.

#Инсталиране на пакета, съдържащ данните
install.packages("UsingR")
#Зареждане на пакета.
library(UsingR)
#Зареждане на данните
data(home)

#информация за структурата на данните
str(home)
'data.frame':   15 obs. of  2 variables:
 $ old: num  64200 72100 87600 59000 83200 ...
 $ new: num  257500 276800 364600 160400 333500 ...

#data.frame е тип данна, която е подобна на матрица с разликата, че може да имаме различни типове данни в колоните.
#първата колона има име "old"
#втората колона "new"

attach(home)
x <- old
y <- new

plot(x,y)

Построяване на линеен модел върху данните
abline(lm(y~x))
#~ е оператор, с който указваме коя е зависимата променлива.

cor(x,y) #ни дава корелационните коефициент на двете величи.

Как да си направим сами data.frame?
1) Правим проучване
Проучването представлява, че сме попитали 4 колеги за техните ръст, тегло и пол.
weight <- c(150, 135, 210, 140)
height <- c(65, 61, 70, 65)
gender <- c('Fe', 'Fe', 'M', 'Fe')
2) Обединяване на данните в data.frame:
study <- data.frame(weight, height, gender)

study 

Понякога имената на колоните са отекчаващо дълги или неуместни. Може да е уместно да ги променим.
вариант 1:
study <- data.frame(w = weight, height, gender)
study
вариант 2:
colnames(study) <- c('w', 'h', 'g')

Достъп и модификация на данни от data.frame:
Достъп
study$w
Модификация
study$w <- c(155, 140, 205, 145)

Именуване на редовете:
rownames(study) <- c('Mila', 'Gabi', 'Dancho', "Viki")
study

Извличане на първа колона от data.frame
study[,1] 
Извличане на първи ред 
study[1,] 
Извличане на втори елемент от първи ред 
study[1,2]
Може да извлечем ред/колона и по тяхното име
study[,'w'] 
Извличане от 2ра до 3та колона:
study[,2:3]
Извличане на 1ва и трета колона:
study[,c(1,3)]
Съшото, но по име:
study[,c('w','g')]

Извличане на всички редове, съдържащи данни за нежния пол:
study[study$g == 'Fe', ]

Извличане на всички наблюдения (4мата колеги) с тегло под 200 килограма и височина над 60 сантиметра.
study[study$w < 200 & study$h > 60, ]

-----------------
Да заредим данните PlantGrowth.
data(PlantGrowth)
head(PlantGrowth)
  weight group
1   4.17  ctrl
2   5.58  ctrl
...
11   4.81  trt1
12   4.17  trt1
...
29   5.80  trt2
30   5.26  trt2

Данните са за теглото на 30 еднотипни растения (например домат), които са разделени в 3 групи и са третирани по 3 различни начина
Група 1: 
Контролната група (ctrl) не е третирана с нищо, тя служи за модел (референтен образец)
Група 2:
Група третирана с вещество тип 1 (trt = treatment)
Група 3:
Група третирана с вещество тип 2

За да разделим 30те наблюдения в 3 отделни групи правим така:
Контролна група:
ctrl <- PlantGrowth[PlantGrowth$group == 'ctrl', ]
Група 2:
trt1 <- PlantGrowth[PlantGrowth$group == 'trt1', ]
Група 3:
trt2 <- PlantGrowth[PlantGrowth$group == 'trt2', ]

grouped_data <- data.frame(ctrl[,1], trt1[,1], trt2[,1])
colnames(grouped_data) <- c("ctrl", "trt1", "trt2")

Да си представим, че групите бяха 100, на ръка ще е мъка да направим това преобразува, а също така има място за човешка грешка, затова друг начин да направим групирането е този:
unstack(PlantGrowth)
Резултатът е data.frame, в който имената на колоните са типът изследване, а редовете измереният резултат(данни получени чрез изследване върху реални неща се наричат "Експериментални данни"). 

boxplot(unstack(PlantGrowth))
Интерпретацията на кутииките с мустаци е следната:
Контролната група си ни служи за отправна точка.
Групата третирана с trt1 си намалила теглото, но има outlier, който си е покачил теглото. Какво правим с outlier-a??? Изяждаме го.
Групата третирана с trt2 си е покачила теглото

Резултатният boxplot, може да направим и по следния начин:
boxplot(PlantGrowth$weight ~ PlantGrowth$group)

#Section 6#
---------Генератори на произволни числа--------- 
Резултатът от генерирането  на произволните числа може да бъде описано като вид разпределение.
R ни дава възможност да генерираме произволни числа в няколко различни вида разпределения.

1. Равномерно разпределени данни
Uniform. Генерира N на брой числа равномерно разпределени в даден интервал.
Синтаксис: runif(брой числа, минимална стойност, максимална стойност)
По подразбиране интервалът е [0,1]

runif(1,0,3) #генерира случайно число в интервала [0,3]
x <- runif(50,0,5)
hist(x, probability=TRUE, col="red", main="uniform data on [0,5]")

#равномерно разпределените данни (uniformly) имат една и съща вероятност да се паднат в произволна част на интервала. 
curve(dunif(x, min=0, max=1),add=T)

2. Нормално разпределени данни
Normal. Генерира N на брой нормално разпределени числа.
Синтаксис: rnorm(брой числа, средно, стандартно отклонение)
По подразбиране средното е 0, а стандартното отклонение 1.
#генериране на 10 резултата от IQ тест.
rnorm(10,100,16) #генерира случайно число със средно 100 и стандартно отклонение 16.
y <- rnorm(10,100,16)
hist(y, probability=TRUE, col="blue", main="normal data with mean=100, sd=16")
curve(dnorm(x, mean=100,sd=16),add=T) #така може да видим теоретичното разпределение на данните.

Задача:
Състои се важен изпит. 300 студенти са се явили и са направили тест, на който могат да получат максимален брой точки 100. След теста прибирате внимателно работите на студентите в раницата си и се засилвате целеустремено към вкъщи, но.. по път решавате да се отбиете в бар и да изпиете само една бира. За ваше щастие и студентско нещастие изпивате няколко и си забравяте чантата с тестовете на студентите :(

Как да се измъкнем от ситуацията?

Отговор:
Взимаме резултатите от миналата година и им правим анализ.
Виждаме, че средно студентите са изкарали 70 точки със стандартно отклонение 12.
За да не дублираме данните, ще направим следната схема:
Генерираме 300 нормално разпределени данни със средно 72 и стандартно отклонение 10. (всички доволни)
lost_exam_results <- rnorm(300,mean=72,sd=10)
#нормално разпределените данни (normal distributed) следват камбановидно разпределение. т.е. стойности по-близо до средните е по-вероятно да се падат.
hist(lost_exam_results)

3. Данни с биномно разпределение
Binomial. Разпределението на данните е спрямо успеха при N независими Бернулиеви опита. Бернулиев опит е такъв, при който резултата е или успех или неуспех.
Синтаксис: rbinom(брой проведени експерименти, брой опита в експеримент, вероятност за успех)
rbinom(1,5,1/6) #1 експеримент, състоящ се от 5 опита, всеки с вероятност 1/6 (т.е. мятам зарче 5 пъти и дали съм метнал произволна намислена от мен цифра от 1 до 6)
rbinom(30,10,1/6) #30 студента мятат 10 пъти зар и броя колко пъти са метнали 3 (например)

s <- rbinom(30,10,1/6)
table(s) # таблица колко студенти са метнали колко 3ки.

y <- rbinom(20,100,.5) #20 студента, хвърлят 100 пъти перфектна монета (перфектна монета = такава, която никога не застава на калъч)
hist(y)
#колкото повече опита правим, толкова по-камбановидно е разпределението.
y <- rbinom(10000,100,.5)
hist(y)

4. Експоненциално разпределение
Exponential. Животът на електрическа крушка. До 2500 часа. 
Синтаксис: rexp(брой числа, параметър)
x=rexp(100,1/2500)
hist(x,probability=TRUE,col=gray(.9),main="exponential mean=2500")
curve(dexp(x,1/2500),add=T)
Въпрос: Защо след 2500 час започва да е много малко вероятно да изгърми?

5.
Генериране на събития с и без повторения
Пример за събития с повторения е хвърлянето на зар.
Пример за събитие без повторение е отбелязани числа на лотариен билет.

Хвърляне на зар:
sample(1:6, 10, replace=TRUE) #10 хвърляния на зар.
Числа на лотариен билет:
sample(1:49, 6) #по подразбиране replace=FALSE

Хвърляне на 2 зара едновременно:
dice <- as.vector(outer(1:6,1:6,paste)) #outer прави декартово произведение (всички възможни 2ки). paste, за да не са умножени, а да са 2ки низове
sample(dice, 5, replace=TRUE) #връща произволна 2ка.

7.
Bootstrap sampling
Bootstrapping е метод за генериране на събития от множество с данни на базата, на които може да се направи статистически извод.
Идеята е, че като проиграем дадена игра (хвърляне на зар, раздаване на карти) няколко пъти, можем да си изведем извод за очакванията ни от нея.
Процесът представлява многократно генериране на събития от извадка, след което формираме статистика върху настъпилите събития.

Да го приложим за данните faithful.
data(faithful)
hist(faithful$eruptions)
hist(faithful$eruptions, breaks=25)
Разпределението е странно.
dev.new()
hist(sample(faithful$eruptions,100, replace=TRUE), breaks=25)
Резултатът е подобно разпреление на оригиналните данни, но не същото.
#hist(sample(faithful$eruptions,272), breaks=25)

dev.off()
dev.off()

Пример за приложение на bootstrapping:
set.seed(333); x<-rnorm(30) #така всеки път генерираната поредица числа ще е една и съща
bootMean <- rep(NA,1000) #генерираме 1000 празни стойности в bootMean.
sampledMean <- rep(NA,1000)
for(i in 1:1000){bootMean[i] <- mean(sample(x,replace=TRUE))}
for(i in 1:1000){sampledMean[i] <- mean(rnorm(30))}
plot(density(bootMean))
lines(density(sampledMean), col='red')

Извод:
Имаме данни за 30 човека.
Правим 1000 варианта на тази извадка.
На симулираните резултати, може да извадим извод за съвсем друга извадка.

Създаване на скрипт:
Създаваме текстов файл (с произволен текстов редактор)
Добавяме съдържание, например:
example <- function(max=5)
{
	for (i in 1:max)
	{
		print(i)
	}
}

Свързване на скрипта към работната среда:
source("пълно_име_на_файл") или относително име комбинирано с .libPath("...")
Извикване на скрипта:
example(15)
